{"version":3,"sources":["../src/worklet/AudioProcessorString.ts","../src/core/AudioRecorder.ts","../src/react/useAudioRecorder.ts"],"names":[],"mappings":"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","file":"index.mjs","sourcesContent":["\n// This file contains the stringified version of the AudioWorkletProcessor.\n// In a real build pipeline, this would be generated automatically.\n// For now, we manually transpile the TS to JS and embed it.\n\nexport const WORKLET_CODE = `\nclass AudioProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.buffer = new Float32Array(0);\n    this.targetSampleRate = 16000;\n    this.vadThreshold = 0.01;\n    this.vadHangoverFrames = 10;\n    this.vadHangoverCounter = 0;\n    this.isSpeaking = false;\n    \n    this.port.onmessage = (event) => {\n      if (event.data.type === 'CONFIG') {\n        // Handle config\n      }\n    };\n  }\n\n  process(inputs, outputs, parameters) {\n    const input = inputs[0];\n    if (!input || input.length === 0) return true;\n\n    const channelData = input[0];\n    \n    // Resample\n    // AudioWorklet global scope has sampleRate\n    const currentSampleRate = sampleRate;\n    const resampledData = this.resample(channelData, currentSampleRate, this.targetSampleRate);\n\n    // VAD\n    const isCurrentlySpeaking = this.detectVoice(resampledData);\n    \n    if (isCurrentlySpeaking) {\n      this.vadHangoverCounter = this.vadHangoverFrames;\n      if (!this.isSpeaking) {\n        this.isSpeaking = true;\n        this.port.postMessage({ type: 'VAD_START' });\n      }\n    } else {\n      if (this.vadHangoverCounter > 0) {\n        this.vadHangoverCounter--;\n      } else if (this.isSpeaking) {\n        this.isSpeaking = false;\n        this.port.postMessage({ type: 'VAD_END' });\n      }\n    }\n\n    if (this.isSpeaking || this.vadHangoverCounter > 0) {\n       const int16Data = this.floatTo16BitPCM(resampledData);\n       this.port.postMessage({ type: 'AUDIO_DATA', data: int16Data.buffer }, [int16Data.buffer]);\n    }\n\n    return true;\n  }\n\n  resample(input, fromRate, toRate) {\n    if (fromRate === toRate) return input;\n    \n    const ratio = fromRate / toRate;\n    const newLength = Math.round(input.length / ratio);\n    const result = new Float32Array(newLength);\n    \n    for (let i = 0; i < newLength; i++) {\n      const originalIndex = i * ratio;\n      const index1 = Math.floor(originalIndex);\n      const index2 = Math.min(index1 + 1, input.length - 1);\n      const weight = originalIndex - index1;\n      \n      result[i] = input[index1] * (1 - weight) + input[index2] * weight;\n    }\n    \n    return result;\n  }\n\n  detectVoice(data) {\n    let sumSquares = 0;\n    for (let i = 0; i < data.length; i++) {\n      sumSquares += data[i] * data[i];\n    }\n    const rms = Math.sqrt(sumSquares / data.length);\n    return rms > this.vadThreshold;\n  }\n\n  floatTo16BitPCM(input) {\n    const output = new Int16Array(input.length);\n    for (let i = 0; i < input.length; i++) {\n      const s = Math.max(-1, Math.min(1, input[i]));\n      output[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;\n    }\n    return output;\n  }\n}\n\nregisterProcessor('audio-processor', AudioProcessor);\n`;\n","\nimport { WORKLET_CODE } from '../worklet/AudioProcessorString';\n\nexport interface AudioRecorderOptions {\n    sampleRate?: number;\n    onDataAvailable?: (data: Int16Array) => void;\n    onVADChange?: (isSpeaking: boolean) => void;\n}\n\nexport class AudioRecorder {\n    private context: AudioContext | null = null;\n    private workletNode: AudioWorkletNode | null = null;\n    private stream: MediaStream | null = null;\n    private options: AudioRecorderOptions;\n    private isRecording = false;\n\n    constructor(options: AudioRecorderOptions) {\n        this.options = options;\n    }\n\n    async start() {\n        if (this.isRecording) return;\n\n        try {\n            this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n\n            // Create AudioContext with desired sample rate if supported, otherwise default\n            // Note: We resample in the worklet, so we can let the context run at native rate (usually 44.1 or 48k)\n            // to avoid hardware resampling issues.\n            this.context = new AudioContext();\n\n            await this.context.resume();\n\n            // Load the worklet\n            // TODO: This needs to be replaced with the actual Blob URL or file path in the final build\n            // For now, we assume a specific path or we will inject it.\n            // We'll use a helper method to get the worklet URL.\n            const workletUrl = this.getWorkletUrl();\n            await this.context.audioWorklet.addModule(workletUrl);\n\n            const source = this.context.createMediaStreamSource(this.stream);\n            this.workletNode = new AudioWorkletNode(this.context, 'audio-processor');\n\n            this.workletNode.port.onmessage = (event) => {\n                const { type, data } = event.data;\n\n                if (type === 'AUDIO_DATA') {\n                    if (this.options.onDataAvailable) {\n                        this.options.onDataAvailable(new Int16Array(data));\n                    }\n                } else if (type === 'VAD_START') {\n                    if (this.options.onVADChange) {\n                        this.options.onVADChange(true);\n                    }\n                } else if (type === 'VAD_END') {\n                    if (this.options.onVADChange) {\n                        this.options.onVADChange(false);\n                    }\n                }\n            };\n\n            source.connect(this.workletNode);\n            // We don't connect to destination to avoid feedback loop (hearing yourself)\n\n            this.isRecording = true;\n        } catch (error) {\n            console.error('Failed to start recording:', error);\n            throw error;\n        }\n    }\n\n    stop() {\n        if (!this.isRecording) return;\n\n        if (this.stream) {\n            this.stream.getTracks().forEach(track => track.stop());\n            this.stream = null;\n        }\n\n        if (this.workletNode) {\n            this.workletNode.disconnect();\n            this.workletNode = null;\n        }\n\n        if (this.context) {\n            this.context.close();\n            this.context = null;\n        }\n\n        this.isRecording = false;\n    }\n\n    // This is the magic part where we will inject the worker code\n    private getWorkletUrl(): string {\n        const blob = new Blob([WORKLET_CODE], { type: 'application/javascript' });\n        return URL.createObjectURL(blob);\n    }\n}\n","\nimport { useState, useRef, useCallback, useEffect } from 'react';\nimport { AudioRecorder } from '../core/AudioRecorder';\n\nexport interface UseAudioRecorderOptions {\n    sampleRate?: number;\n}\n\nexport const useAudioRecorder = (options: UseAudioRecorderOptions = {}) => {\n    const [isRecording, setIsRecording] = useState(false);\n    const [isSpeaking, setIsSpeaking] = useState(false);\n    const recorderRef = useRef<AudioRecorder | null>(null);\n\n    // We expose a method to set the socket or callback for data\n    const start = useCallback(async (onData?: (data: Int16Array) => void) => {\n        if (recorderRef.current) return;\n\n        const recorder = new AudioRecorder({\n            sampleRate: options.sampleRate,\n            onDataAvailable: (data) => {\n                if (onData) onData(data);\n            },\n            onVADChange: (speaking) => {\n                setIsSpeaking(speaking);\n            }\n        });\n\n        try {\n            await recorder.start();\n            recorderRef.current = recorder;\n            setIsRecording(true);\n        } catch (err) {\n            console.error(\"Error starting recorder:\", err);\n        }\n    }, [options.sampleRate]);\n\n    const stop = useCallback(() => {\n        if (recorderRef.current) {\n            recorderRef.current.stop();\n            recorderRef.current = null;\n            setIsRecording(false);\n            setIsSpeaking(false);\n        }\n    }, []);\n\n    useEffect(() => {\n        return () => {\n            if (recorderRef.current) {\n                recorderRef.current.stop();\n            }\n        };\n    }, []);\n\n    return {\n        start,\n        stop,\n        isRecording,\n        isSpeaking\n    };\n};\n"]}