{"version":3,"sources":["../src/worklet/AudioProcessorString.ts","../src/core/VADAdapter.ts","../src/core/AudioRecorder.ts","../src/react/useAudioRecorder.ts","../src/core/AudioPlayer.ts","../src/core/BrowserUtils.ts","../src/react/useLiveAudio.ts","../src/core/TransportAdapter.ts","../src/react/useAudioVisualizer.ts","../src/react/useAudioSocket.ts"],"names":["useState","useRef","useCallback","useEffect"],"mappings":"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","file":"index.mjs","sourcesContent":["\n// This file contains the stringified version of the AudioWorkletProcessor.\n// In a real build pipeline, this would be generated automatically.\n// For now, we manually transpile the TS to JS and embed it.\n\nexport const WORKLET_CODE = `\nclass AudioProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.buffer = new Float32Array(0);\n    this.targetSampleRate = 16000;\n    this.vadThreshold = 0.01;\n    this.vadHangoverCounter = 0;\n    this.isSpeaking = false;\n    this.speakingFrames = 0;\n    \n    this.port.onmessage = (event) => {\n      if (event.data.type === 'CONFIG') {\n        if (event.data.vadThreshold !== undefined) {\n          this.vadThreshold = event.data.vadThreshold;\n        }\n      }\n    };\n  }\n\n  process(inputs, outputs, parameters) {\n    const input = inputs[0];\n    if (!input || input.length === 0) return true;\n\n    const channelData = input[0];\n    \n    // Resample\n    // AudioWorklet global scope has sampleRate\n    const currentSampleRate = sampleRate;\n    const resampledData = this.resample(channelData, currentSampleRate, this.targetSampleRate);\n\n    // VAD\n    const isCurrentlySpeaking = this.detectVoice(resampledData);\n    \n    if (isCurrentlySpeaking) {\n      if (!this.isSpeaking) {\n        this.isSpeaking = true;\n        this.speakingFrames = 0;\n        this.port.postMessage({ type: 'VAD_START' });\n      }\n      this.speakingFrames += 1;\n      this.vadHangoverCounter = this.calculateHangover(this.speakingFrames);\n    } else {\n      if (this.vadHangoverCounter > 0) {\n        this.vadHangoverCounter--;\n      } else if (this.isSpeaking) {\n        this.isSpeaking = false;\n        this.port.postMessage({ type: 'VAD_END' });\n      }\n    }\n\n    if (this.isSpeaking || this.vadHangoverCounter > 0) {\n       const int16Data = this.floatTo16BitPCM(resampledData);\n       this.port.postMessage({ type: 'AUDIO_DATA', data: int16Data.buffer }, [int16Data.buffer]);\n    }\n\n    return true;\n  }\n\n  resample(input, fromRate, toRate) {\n    if (fromRate === toRate) return input;\n    \n    const ratio = fromRate / toRate;\n    const newLength = Math.round(input.length / ratio);\n    const result = new Float32Array(newLength);\n    \n    for (let i = 0; i < newLength; i++) {\n      const originalIndex = i * ratio;\n      const index1 = Math.floor(originalIndex);\n      const index2 = Math.min(index1 + 1, input.length - 1);\n      const weight = originalIndex - index1;\n      \n      result[i] = input[index1] * (1 - weight) + input[index2] * weight;\n    }\n    \n    return result;\n  }\n\n  detectVoice(data) {\n    let sumSquares = 0;\n    for (let i = 0; i < data.length; i++) {\n      sumSquares += data[i] * data[i];\n    }\n    const rms = Math.sqrt(sumSquares / data.length);\n    return rms > this.vadThreshold;\n  }\n\n  floatTo16BitPCM(input) {\n    const output = new Int16Array(input.length);\n    for (let i = 0; i < input.length; i++) {\n      // Soft-clip limiter\n      const s = Math.tanh(input[i]);\n      output[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;\n    }\n    return output;\n  }\n\n  calculateHangover(speakingFrames) {\n    // Assuming ~128 samples per chunk at 16kHz = 8ms\n    // 2 seconds = 250 chunks\n    if (speakingFrames > 250) {\n      return 187; // ~1.5s\n    }\n    return 62; // ~500ms\n  }\n}\n\nregisterProcessor('audio-processor', AudioProcessor);\n`;\n","import * as ort from 'onnxruntime-web';\n\nexport interface VADAdapter {\n    process(audioFrame: Float32Array): Promise<boolean>;\n    reset(): void;\n}\n\nexport class SileroVADAdapter implements VADAdapter {\n    private loaded = false;\n    private session: ort.InferenceSession | null = null;\n    private h: ort.Tensor | null = null;\n    private c: ort.Tensor | null = null;\n    private readonly sr: ort.Tensor;\n\n    constructor(private modelUrl: string) {\n        this.sr = new ort.Tensor('int64', new BigInt64Array([16000n]));\n    }\n\n    async load() {\n        if (this.loaded) return;\n        try {\n            this.session = await ort.InferenceSession.create(this.modelUrl);\n            this.reset();\n            this.loaded = true;\n        } catch (e) {\n            console.error(\"Failed to load VAD model\", e);\n        }\n    }\n\n    async process(audioFrame: Float32Array): Promise<boolean> {\n        if (!this.loaded || !this.session || !this.h || !this.c) {\n            // Fallback to energy check if model not loaded\n            let sum = 0;\n            for (let i = 0; i < audioFrame.length; i++) {\n                sum += audioFrame[i] * audioFrame[i];\n            }\n            return Math.sqrt(sum / audioFrame.length) > 0.02;\n        }\n\n        const input = new ort.Tensor('float32', audioFrame, [1, audioFrame.length]);\n\n        const feeds: Record<string, ort.Tensor> = {\n            input: input,\n            sr: this.sr,\n            h: this.h,\n            c: this.c\n        };\n\n        const results = await this.session.run(feeds);\n\n        // Update states\n        this.h = results.hn;\n        this.c = results.cn;\n\n        const output = results.output;\n        const probability = output.data[0] as number;\n\n        return probability > 0.5;\n    }\n\n    reset() {\n        // Reset internal state (RNN states) for Silero (2, 1, 64)\n        const zeros = new Float32Array(2 * 1 * 64).fill(0);\n        this.h = new ort.Tensor('float32', zeros, [2, 1, 64]);\n        this.c = new ort.Tensor('float32', zeros, [2, 1, 64]);\n    }\n}\n","\nimport { WORKLET_CODE } from '../worklet/AudioProcessorString';\n\nimport { SileroVADAdapter } from './VADAdapter';\n\nexport interface AudioDataPayload {\n    data: Int16Array | Uint8Array;\n    timestamp: number;\n    sequence: number;\n    encoding: 'pcm' | 'opus';\n}\n\nexport interface AudioRecorderOptions {\n    sampleRate?: number;\n    onDataAvailable?: (payload: AudioDataPayload) => void;\n    onVADChange?: (isSpeaking: boolean) => void;\n    audioConstraints?: MediaTrackConstraints;\n    vadThreshold?: number;\n    vadModelUrl?: string;\n    bufferSize?: number; // Size in samples (e.g., 4096)\n    encoder?: 'pcm' | 'opus';\n}\n\nexport class AudioRecorder {\n    private context: AudioContext | null = null;\n    private workletNode: AudioWorkletNode | null = null;\n    private stream: MediaStream | null = null;\n    private options: AudioRecorderOptions;\n    private isRecording = false;\n    private isPaused = false;\n    private analyser: AnalyserNode | null = null;\n    private vadAdapter: SileroVADAdapter | null = null;\n\n    // Buffering state\n    private buffer: Int16Array = new Int16Array(0);\n    private sequenceNumber = 0;\n\n    // Encoder state\n    private audioEncoder: any = null; // Type 'AudioEncoder' is not available in all TS envs yet\n\n    constructor(options: AudioRecorderOptions) {\n        this.options = options;\n        if (options.vadModelUrl) {\n            this.vadAdapter = new SileroVADAdapter(options.vadModelUrl);\n        }\n    }\n\n    async start() {\n        if (this.isRecording) return;\n        this.isPaused = false;\n        this.buffer = new Int16Array(0);\n        this.sequenceNumber = 0;\n\n        try {\n            if (this.vadAdapter) {\n                await this.vadAdapter.load();\n            }\n\n            // Initialize Opus Encoder if requested\n            if (this.options.encoder === 'opus') {\n                if (typeof window.AudioEncoder === 'undefined') {\n                    console.error('AudioEncoder is not supported in this browser. Falling back to PCM.');\n                    this.options.encoder = 'pcm';\n                } else {\n                    this.audioEncoder = new (window as any).AudioEncoder({\n                        output: (chunk: any) => {\n                            // chunk is EncodedAudioChunk\n                            const buffer = new Uint8Array(chunk.byteLength);\n                            chunk.copyTo(buffer);\n\n                            this.emitData(buffer, 'opus');\n                        },\n                        error: (e: any) => {\n                            console.error('AudioEncoder error', e);\n                        }\n                    });\n\n                    this.audioEncoder.configure({\n                        codec: 'opus',\n                        sampleRate: this.options.sampleRate || 16000,\n                        numberOfChannels: 1,\n                        bitrate: 24000 // 24kbps is good for speech\n                    });\n                }\n            }\n\n            this.stream = await navigator.mediaDevices.getUserMedia({\n                audio: this.options.audioConstraints ?? {\n                    echoCancellation: true,\n                    noiseSuppression: true,\n                    autoGainControl: true\n                }\n            });\n\n            // Create AudioContext with desired sample rate if supported, otherwise default\n            // Note: We resample in the worklet, so we can let the context run at native rate (usually 44.1 or 48k)\n            // to avoid hardware resampling issues.\n            this.context = new AudioContext();\n\n            await this.context.resume();\n\n            // Load the worklet\n            // TODO: This needs to be replaced with the actual Blob URL or file path in the final build\n            // For now, we assume a specific path or we will inject it.\n            // We'll use a helper method to get the worklet URL.\n            const workletUrl = this.getWorkletUrl();\n            await this.context.audioWorklet.addModule(workletUrl);\n\n            const source = this.context.createMediaStreamSource(this.stream);\n            this.workletNode = new AudioWorkletNode(this.context, 'audio-processor');\n\n            // Send initial config\n            if (this.options.vadThreshold !== undefined) {\n                this.workletNode.port.postMessage({\n                    type: 'CONFIG',\n                    vadThreshold: this.options.vadThreshold\n                });\n            }\n\n            // Visualizer Support\n            this.analyser = this.context.createAnalyser();\n            this.analyser.fftSize = 256;\n            source.connect(this.analyser);\n\n            this.workletNode.port.onmessage = async (event) => {\n                const { type, data } = event.data;\n\n                if (type === 'AUDIO_DATA') {\n                    if (!this.isPaused) {\n                        const int16Data = new Int16Array(data);\n\n                        // Handle Buffering\n                        if (this.options.bufferSize && this.options.bufferSize > 0) {\n                            const newBuffer = new Int16Array(this.buffer.length + int16Data.length);\n                            newBuffer.set(this.buffer);\n                            newBuffer.set(int16Data, this.buffer.length);\n                            this.buffer = newBuffer;\n\n                            while (this.buffer.length >= this.options.bufferSize) {\n                                const chunk = this.buffer.slice(0, this.options.bufferSize);\n                                this.buffer = this.buffer.slice(this.options.bufferSize);\n\n                                this.processData(chunk);\n                            }\n                        } else {\n                            // No buffering, emit immediately\n                            this.processData(int16Data);\n                        }\n\n                        // If we have an AI VAD adapter, use it\n                        if (this.vadAdapter) {\n                            // Convert Int16 to Float32 for VAD\n                            const float32Data = new Float32Array(int16Data.length);\n                            for (let i = 0; i < int16Data.length; i++) {\n                                float32Data[i] = int16Data[i] / 32768.0;\n                            }\n\n                            const isSpeaking = await this.vadAdapter.process(float32Data);\n                            if (this.options.onVADChange) {\n                                this.options.onVADChange(isSpeaking);\n                            }\n                        }\n                    }\n                } else if (type === 'VAD_START') {\n                    // Only use internal VAD if no external adapter is present\n                    if (!this.vadAdapter && this.options.onVADChange) {\n                        this.options.onVADChange(true);\n                    }\n                } else if (type === 'VAD_END') {\n                    // Only use internal VAD if no external adapter is present\n                    if (!this.vadAdapter && this.options.onVADChange) {\n                        this.options.onVADChange(false);\n                    }\n                }\n            };\n\n            source.connect(this.workletNode);\n            // We don't connect to destination to avoid feedback loop (hearing yourself)\n\n            this.isRecording = true;\n        } catch (error) {\n            console.error('Failed to start recording:', error);\n            throw error;\n        }\n    }\n\n    private processData(data: Int16Array) {\n        if (this.options.encoder === 'opus' && this.audioEncoder) {\n            // Encode to Opus\n            // We need to create an AudioData object\n            // Note: AudioData expects Float32 usually, but let's check support for Int16\n            // Actually AudioData init takes: format, sampleRate, numberOfFrames, numberOfChannels, timestamp, data\n\n            // Convert Int16 to Float32 for AudioData (WebCodecs usually prefers this or specific format)\n            const float32Data = new Float32Array(data.length);\n            for (let i = 0; i < data.length; i++) {\n                float32Data[i] = data[i] / 32768.0;\n            }\n\n            const audioData = new (window as any).AudioData({\n                format: 'f32',\n                sampleRate: this.options.sampleRate || 16000,\n                numberOfFrames: data.length,\n                numberOfChannels: 1,\n                timestamp: Date.now() * 1000, // microseconds\n                data: float32Data\n            });\n\n            this.audioEncoder.encode(audioData);\n            audioData.close();\n        } else {\n            // PCM\n            this.emitData(data, 'pcm');\n        }\n    }\n\n    private emitData(data: Int16Array | Uint8Array, encoding: 'pcm' | 'opus') {\n        if (this.options.onDataAvailable) {\n            this.options.onDataAvailable({\n                data,\n                timestamp: Date.now(),\n                sequence: this.sequenceNumber++,\n                encoding\n            });\n        }\n    }\n\n    stop() {\n        if (!this.isRecording) return;\n\n        if (this.stream) {\n            this.stream.getTracks().forEach(track => track.stop());\n            this.stream = null;\n        }\n\n        if (this.workletNode) {\n            this.workletNode.disconnect();\n            this.workletNode = null;\n        }\n\n        if (this.context) {\n            this.context.close();\n            this.context = null;\n        }\n\n        this.isRecording = false;\n        this.isPaused = false;\n    }\n\n    pause() {\n        if (this.isRecording) {\n            this.isPaused = true;\n            this.context?.suspend();\n        }\n    }\n\n    resume() {\n        if (this.isRecording && this.isPaused) {\n            this.isPaused = false;\n            this.context?.resume();\n        }\n    }\n\n    // This is the magic part where we will inject the worker code\n    private getWorkletUrl(): string {\n        const blob = new Blob([WORKLET_CODE], { type: 'application/javascript' });\n        return URL.createObjectURL(blob);\n    }\n\n    getFrequencies(): Float32Array {\n        if (!this.analyser) return new Float32Array(0);\n        const data = new Float32Array(this.analyser.frequencyBinCount);\n        this.analyser.getFloatFrequencyData(data);\n        return data;\n    }\n\n    /**\n     * Converts an array of Int16Array chunks into a WAV Blob.\n     * @param chunks The audio data chunks (Int16Array)\n     * @param sampleRate The sample rate of the audio data (default 16000)\n     * @returns A Blob containing the WAV file\n     */\n    static exportWAV(chunks: Int16Array[], sampleRate: number = 16000): Blob {\n        const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);\n        const buffer = new ArrayBuffer(44 + totalLength * 2);\n        const view = new DataView(buffer);\n\n        // RIFF chunk descriptor\n        this.writeString(view, 0, 'RIFF');\n        view.setUint32(4, 36 + totalLength * 2, true);\n        this.writeString(view, 8, 'WAVE');\n\n        // fmt sub-chunk\n        this.writeString(view, 12, 'fmt ');\n        view.setUint32(16, 16, true); // Subchunk1Size (16 for PCM)\n        view.setUint16(20, 1, true); // AudioFormat (1 for PCM)\n        view.setUint16(22, 1, true); // NumChannels (1 for Mono)\n        view.setUint32(24, sampleRate, true); // SampleRate\n        view.setUint32(28, sampleRate * 2, true); // ByteRate (SampleRate * NumChannels * BitsPerSample/8)\n        view.setUint16(32, 2, true); // BlockAlign (NumChannels * BitsPerSample/8)\n        view.setUint16(34, 16, true); // BitsPerSample\n\n        // data sub-chunk\n        this.writeString(view, 36, 'data');\n        view.setUint32(40, totalLength * 2, true);\n\n        // Write PCM samples\n        let offset = 44;\n        for (const chunk of chunks) {\n            for (let i = 0; i < chunk.length; i++) {\n                view.setInt16(offset, chunk[i], true);\n                offset += 2;\n            }\n        }\n\n        return new Blob([view], { type: 'audio/wav' });\n    }\n\n    private static writeString(view: DataView, offset: number, string: string) {\n        for (let i = 0; i < string.length; i++) {\n            view.setUint8(offset + i, string.charCodeAt(i));\n        }\n    }\n}\n","\nimport { useState, useRef, useCallback, useEffect } from 'react';\nimport { AudioRecorder, AudioDataPayload } from '../core/AudioRecorder';\n\nexport interface UseAudioRecorderOptions {\n    sampleRate?: number;\n    audioConstraints?: MediaTrackConstraints;\n    vadThreshold?: number;\n    vadModelUrl?: string;\n    bufferSize?: number;\n    encoder?: 'pcm' | 'opus';\n}\n\nexport const useAudioRecorder = (options: UseAudioRecorderOptions = {}) => {\n    const [isRecording, setIsRecording] = useState(false);\n    const [isPaused, setIsPaused] = useState(false);\n    const [isSpeaking, setIsSpeaking] = useState(false);\n    const [recordingBlob, setRecordingBlob] = useState<Blob | null>(null);\n    const [recordingTime, setRecordingTime] = useState(0);\n\n    const recorderRef = useRef<AudioRecorder | null>(null);\n    const chunksRef = useRef<(Int16Array | Uint8Array)[]>([]);\n    const startTimeRef = useRef<number>(0);\n    const pausedTimeRef = useRef<number>(0);\n    const timerRef = useRef<any>(null);\n\n    // We expose a method to set the socket or callback for data\n    const start = useCallback(async (onData?: (payload: AudioDataPayload) => void) => {\n        if (recorderRef.current) return;\n\n        chunksRef.current = [];\n        setRecordingBlob(null);\n        setRecordingTime(0);\n        pausedTimeRef.current = 0;\n\n        const recorder = new AudioRecorder({\n            sampleRate: options.sampleRate,\n            audioConstraints: options.audioConstraints,\n            vadThreshold: options.vadThreshold,\n            vadModelUrl: options.vadModelUrl,\n            bufferSize: options.bufferSize,\n            encoder: options.encoder,\n            onDataAvailable: (payload) => {\n                chunksRef.current.push(payload.data);\n                if (onData) onData(payload);\n            },\n            onVADChange: (speaking) => {\n                setIsSpeaking(speaking);\n            }\n        });\n\n        try {\n            await recorder.start();\n            recorderRef.current = recorder;\n            setIsRecording(true);\n            setIsPaused(false);\n            startTimeRef.current = Date.now();\n\n            timerRef.current = setInterval(() => {\n                if (!pausedTimeRef.current) {\n                    setRecordingTime(Math.floor((Date.now() - startTimeRef.current) / 1000));\n                }\n            }, 1000);\n\n        } catch (err) {\n            console.error(\"Error starting recorder:\", err);\n        }\n    }, [options.sampleRate, options.audioConstraints, options.vadThreshold]);\n\n    const stop = useCallback(() => {\n        if (recorderRef.current) {\n            recorderRef.current.stop();\n            recorderRef.current = null;\n            setIsRecording(false);\n            setIsPaused(false);\n            setIsSpeaking(false);\n\n            if (timerRef.current) {\n                clearInterval(timerRef.current);\n                timerRef.current = null;\n            }\n\n            let blob: Blob;\n            if (options.encoder === 'opus') {\n                // For Opus, chunks are Uint8Array packets. \n                // We can just blob them together, but usually they need a container (Ogg/WebM).\n                // For simplicity in this raw lib, we just return the raw packets as a blob.\n                // A real app would use a container muxer.\n                blob = new Blob(chunksRef.current as any[], { type: 'audio/ogg' });\n            } else {\n                blob = AudioRecorder.exportWAV(chunksRef.current as Int16Array[], options.sampleRate);\n            }\n            setRecordingBlob(blob);\n        }\n    }, [options.sampleRate, options.encoder]);\n\n    const pause = useCallback(() => {\n        if (recorderRef.current && isRecording && !isPaused) {\n            recorderRef.current.pause();\n            setIsPaused(true);\n            if (timerRef.current) {\n                clearInterval(timerRef.current);\n                timerRef.current = null;\n            }\n            // Store the duration so far\n            pausedTimeRef.current = Date.now() - startTimeRef.current;\n        }\n    }, [isRecording, isPaused]);\n\n    const resume = useCallback(() => {\n        if (recorderRef.current && isRecording && isPaused) {\n            recorderRef.current.resume();\n            setIsPaused(false);\n\n            // Adjust start time so the elapsed time continues correctly\n            startTimeRef.current = Date.now() - pausedTimeRef.current;\n            pausedTimeRef.current = 0;\n\n            timerRef.current = setInterval(() => {\n                setRecordingTime(Math.floor((Date.now() - startTimeRef.current) / 1000));\n            }, 1000);\n        }\n    }, [isRecording, isPaused]);\n\n    useEffect(() => {\n        return () => {\n            if (recorderRef.current) {\n                recorderRef.current.stop();\n            }\n            if (timerRef.current) {\n                clearInterval(timerRef.current);\n            }\n        };\n    }, []);\n\n    const getVisualizerData = useCallback(() => {\n        if (recorderRef.current) {\n            return recorderRef.current.getFrequencies();\n        }\n        return new Float32Array(0);\n    }, []);\n\n    return {\n        start,\n        stop,\n        pause,\n        resume,\n        isRecording,\n        isPaused,\n        isSpeaking,\n        recordingBlob,\n        recordingTime,\n        getVisualizerData\n    };\n};\n","export class AudioPlayer {\n    private context: AudioContext;\n    private sampleRate: number;\n    private nextStartTime: number = 0;\n    private scheduledSources: AudioBufferSourceNode[] = [];\n    private readonly BUFFER_MS = 40; // 40ms initial buffer\n\n    constructor(context: AudioContext, sampleRate: number = 24000) {\n        this.context = context;\n        this.sampleRate = sampleRate;\n    }\n\n    addAudio(data: Int16Array) {\n        const float32 = new Float32Array(data.length);\n        for (let i = 0; i < data.length; i++) {\n            float32[i] = data[i] / 32768; // 0x8000\n        }\n\n        const buffer = this.context.createBuffer(1, float32.length, this.sampleRate);\n        buffer.copyToChannel(float32, 0);\n\n        const currentTime = this.context.currentTime;\n\n        // Jitter Buffer Logic:\n        // If we are starving (nextStartTime < currentTime), add safety buffer\n        if (this.nextStartTime < currentTime) {\n            this.nextStartTime = currentTime + (this.BUFFER_MS / 1000);\n        }\n\n        // Elastic Logic:\n        // Calculate latency\n        const latency = this.nextStartTime - currentTime;\n        let playbackRate = 1.0;\n        if (latency > 0.2) { // If > 200ms latency, speed up\n            playbackRate = 1.05;\n        }\n\n        const source = this.context.createBufferSource();\n        source.buffer = buffer;\n        source.playbackRate.value = playbackRate;\n        source.connect(this.context.destination);\n        source.start(this.nextStartTime);\n\n        this.scheduledSources.push(source);\n\n        // Cleanup finished sources\n        source.onended = () => {\n            const index = this.scheduledSources.indexOf(source);\n            if (index > -1) {\n                this.scheduledSources.splice(index, 1);\n            }\n        };\n\n        this.nextStartTime += buffer.duration / playbackRate;\n    }\n\n    clear() {\n        this.scheduledSources.forEach(source => {\n            try {\n                source.stop();\n            } catch (e) {\n                // ignore\n            }\n        });\n        this.scheduledSources = [];\n        this.nextStartTime = 0;\n    }\n}\n","export const unlockAudioContext = async (context: AudioContext) => {\n    if (context.state === 'running') return;\n\n    const unlock = () => {\n        // Create a short silent buffer\n        const buffer = context.createBuffer(1, 1, 22050);\n        const source = context.createBufferSource();\n        source.buffer = buffer;\n        source.connect(context.destination);\n        source.start(0);\n\n        if (context.state !== 'running') {\n            context.resume();\n        }\n\n        // Remove listeners once triggered\n        document.removeEventListener('click', unlock);\n        document.removeEventListener('touchstart', unlock);\n        document.removeEventListener('keydown', unlock);\n    };\n\n    // Listen for any interaction\n    document.addEventListener('click', unlock);\n    document.addEventListener('touchstart', unlock);\n    document.addEventListener('keydown', unlock);\n};\n","import { useState, useEffect, useRef, useCallback } from 'react';\nimport { AudioRecorder } from '../core/AudioRecorder';\nimport { AudioPlayer } from '../core/AudioPlayer';\nimport { TransportAdapter } from '../core/TransportAdapter';\nimport { unlockAudioContext } from '../core/BrowserUtils';\n\nexport type LiveAudioState = 'idle' | 'listening' | 'thinking' | 'speaking';\n\nexport interface UseLiveAudioOptions {\n    transport: TransportAdapter;\n    sampleRate?: number;\n}\n\nexport const useLiveAudio = ({ transport, sampleRate = 24000 }: UseLiveAudioOptions) => {\n    const [state, setState] = useState<LiveAudioState>('idle');\n    const [frequencyData, setFrequencyData] = useState<Float32Array>(new Float32Array(0));\n    const recorderRef = useRef<AudioRecorder | null>(null);\n    const playerRef = useRef<AudioPlayer | null>(null);\n    const audioContextRef = useRef<AudioContext | null>(null);\n    const animationFrameRef = useRef<number | null>(null);\n\n    const start = useCallback(async () => {\n        try {\n            // 1. Setup AudioContext\n            // We use the browser's native sample rate for the context to avoid issues, \n            // but we tell the recorder/player what our target rate is.\n            const context = new AudioContext();\n            audioContextRef.current = context;\n            await unlockAudioContext(context);\n\n            // 2. Setup Player\n            const player = new AudioPlayer(context, sampleRate);\n            playerRef.current = player;\n\n            // 3. Setup Recorder\n            const recorder = new AudioRecorder({\n                sampleRate,\n                onDataAvailable: (data) => {\n                    transport.send(data);\n                },\n                onVADChange: (isSpeaking) => {\n                    if (isSpeaking) {\n                        setState('listening');\n                        // Barge-In: Clear player\n                        player.clear();\n                        // Send cancel\n                        transport.send({ type: 'cancel_response' });\n                    } else {\n                        setState('thinking');\n                    }\n                }\n            });\n            recorderRef.current = recorder;\n\n            // 4. Connect Transport\n            await transport.connect((data) => {\n                // Received audio from AI\n                if (data instanceof ArrayBuffer || data instanceof Int16Array) {\n                    setState('speaking');\n                    // Ensure data is Int16Array\n                    const audioData = data instanceof Int16Array ? data : new Int16Array(data);\n                    player.addAudio(audioData);\n                }\n            });\n\n            await recorder.start();\n            setState('listening'); // Initial state\n\n            // Visualizer Loop\n            const updateVisualizer = () => {\n                if (recorderRef.current) {\n                    const data = recorderRef.current.getFrequencies();\n                    setFrequencyData(data);\n                }\n                animationFrameRef.current = requestAnimationFrame(updateVisualizer);\n            };\n            updateVisualizer();\n        } catch (error) {\n            console.error(\"Failed to start live audio:\", error);\n            setState('idle');\n        }\n\n    }, [transport, sampleRate]);\n\n    const stop = useCallback(() => {\n        if (animationFrameRef.current) {\n            cancelAnimationFrame(animationFrameRef.current);\n        }\n        recorderRef.current?.stop();\n        playerRef.current?.clear();\n        transport.disconnect();\n        setState('idle');\n    }, [transport]);\n\n    useEffect(() => {\n        return () => {\n            stop();\n        };\n    }, [stop]);\n\n    return {\n        start,\n        stop,\n        state,\n        frequencyData\n    };\n};\n","export interface TransportAdapter {\n    connect(onMessage: (data: any) => void): Promise<void>;\n    send(data: any): void;\n    disconnect(): void;\n    onStateChange?: (state: 'connected' | 'connecting' | 'disconnected') => void;\n}\n\nexport abstract class BaseTransportAdapter implements TransportAdapter {\n    protected state: 'connected' | 'connecting' | 'disconnected' = 'disconnected';\n    public onStateChange?: (state: 'connected' | 'connecting' | 'disconnected') => void;\n\n    abstract connect(onMessage: (data: any) => void): Promise<void>;\n    abstract send(data: any): void;\n    abstract disconnect(): void;\n\n    protected setState(newState: 'connected' | 'connecting' | 'disconnected') {\n        this.state = newState;\n        if (this.onStateChange) {\n            this.onStateChange(newState);\n        }\n    }\n\n    // Exponential Backoff Reconnection Logic\n    protected async withBackoff(fn: () => Promise<void>) {\n        let attempt = 0;\n        while (true) {\n            try {\n                this.setState('connecting');\n                await fn();\n                this.setState('connected');\n                return;\n            } catch (e) {\n                attempt++;\n                this.setState('disconnected'); // Or 'reconnecting'\n\n                // Wait 200ms, 500ms, 1s...\n                const delay = attempt === 1 ? 200 : Math.min(500 * Math.pow(2, attempt - 2), 10000);\n\n                console.warn(`Connection failed, retrying in ${delay}ms...`, e);\n                await new Promise(r => setTimeout(r, delay));\n            }\n        }\n    }\n}\n","import { useState, useEffect, useRef } from 'react';\n\n/**\n * Hook to get real-time frequency data for visualization.\n * @param getVisualizerData Function that returns the current frequency data (Float32Array).\n * @returns The current frequency data as a Float32Array.\n */\nexport const useAudioVisualizer = (getVisualizerData: () => Float32Array) => {\n    const [data, setData] = useState<Float32Array>(new Float32Array(0));\n    const animationFrameRef = useRef<number | null>(null);\n\n    useEffect(() => {\n        const loop = () => {\n            const newData = getVisualizerData();\n            // We always update to keep the animation smooth, even if zeros\n            setData(newData);\n            animationFrameRef.current = requestAnimationFrame(loop);\n        };\n\n        loop();\n\n        return () => {\n            if (animationFrameRef.current) {\n                cancelAnimationFrame(animationFrameRef.current);\n            }\n        };\n    }, [getVisualizerData]);\n\n    return data;\n};\n","import { useState, useRef, useCallback, useEffect } from 'react';\n\nexport interface UseAudioSocketOptions {\n    onOpen?: () => void;\n    onClose?: () => void;\n    onError?: (error: Event) => void;\n    onMessage?: (event: MessageEvent) => void;\n}\n\nexport const useAudioSocket = (url: string, options: UseAudioSocketOptions = {}) => {\n    const [state, setState] = useState<'connecting' | 'open' | 'closed' | 'error'>('closed');\n    const socketRef = useRef<WebSocket | null>(null);\n\n    const connect = useCallback(() => {\n        if (socketRef.current) return;\n\n        try {\n            setState('connecting');\n            const socket = new WebSocket(url);\n            socket.binaryType = 'arraybuffer';\n\n            socket.onopen = () => {\n                setState('open');\n                if (options.onOpen) options.onOpen();\n            };\n\n            socket.onclose = () => {\n                setState('closed');\n                socketRef.current = null;\n                if (options.onClose) options.onClose();\n            };\n\n            socket.onerror = (error) => {\n                setState('error');\n                if (options.onError) options.onError(error);\n            };\n\n            socket.onmessage = (event) => {\n                if (options.onMessage) options.onMessage(event);\n            };\n\n            socketRef.current = socket;\n        } catch (e) {\n            setState('error');\n            console.error('WebSocket connection failed', e);\n        }\n    }, [url, options]);\n\n    const disconnect = useCallback(() => {\n        if (socketRef.current) {\n            socketRef.current.close();\n            socketRef.current = null;\n            setState('closed');\n        }\n    }, []);\n\n    const send = useCallback((data: any) => {\n        if (socketRef.current && socketRef.current.readyState === WebSocket.OPEN) {\n            socketRef.current.send(data);\n        }\n    }, []);\n\n    // Cleanup on unmount\n    useEffect(() => {\n        return () => {\n            if (socketRef.current) {\n                socketRef.current.close();\n            }\n        };\n    }, []);\n\n    return {\n        connect,\n        disconnect,\n        send,\n        state,\n        socket: socketRef.current\n    };\n};\n"]}