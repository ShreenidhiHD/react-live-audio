{"version":3,"sources":["../src/worklet/AudioProcessorString.ts","../src/core/AudioRecorder.ts","../src/react/useAudioRecorder.ts","../src/core/AudioPlayer.ts","../src/core/BrowserUtils.ts","../src/react/useLiveAudio.ts","../src/core/TransportAdapter.ts","../src/core/VADAdapter.ts"],"names":["useState","useRef","useCallback","useEffect","ort"],"mappings":"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","file":"index.js","sourcesContent":["\n// This file contains the stringified version of the AudioWorkletProcessor.\n// In a real build pipeline, this would be generated automatically.\n// For now, we manually transpile the TS to JS and embed it.\n\nexport const WORKLET_CODE = `\nclass AudioProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.buffer = new Float32Array(0);\n    this.targetSampleRate = 16000;\n    this.vadThreshold = 0.01;\n    this.vadHangoverCounter = 0;\n    this.isSpeaking = false;\n    this.speakingFrames = 0;\n    \n    this.port.onmessage = (event) => {\n      if (event.data.type === 'CONFIG') {\n        // Handle config\n      }\n    };\n  }\n\n  process(inputs, outputs, parameters) {\n    const input = inputs[0];\n    if (!input || input.length === 0) return true;\n\n    const channelData = input[0];\n    \n    // Resample\n    // AudioWorklet global scope has sampleRate\n    const currentSampleRate = sampleRate;\n    const resampledData = this.resample(channelData, currentSampleRate, this.targetSampleRate);\n\n    // VAD\n    const isCurrentlySpeaking = this.detectVoice(resampledData);\n    \n    if (isCurrentlySpeaking) {\n      if (!this.isSpeaking) {\n        this.isSpeaking = true;\n        this.speakingFrames = 0;\n        this.port.postMessage({ type: 'VAD_START' });\n      }\n      this.speakingFrames += 1;\n      this.vadHangoverCounter = this.calculateHangover(this.speakingFrames);\n    } else {\n      if (this.vadHangoverCounter > 0) {\n        this.vadHangoverCounter--;\n      } else if (this.isSpeaking) {\n        this.isSpeaking = false;\n        this.port.postMessage({ type: 'VAD_END' });\n      }\n    }\n\n    if (this.isSpeaking || this.vadHangoverCounter > 0) {\n       const int16Data = this.floatTo16BitPCM(resampledData);\n       this.port.postMessage({ type: 'AUDIO_DATA', data: int16Data.buffer }, [int16Data.buffer]);\n    }\n\n    return true;\n  }\n\n  resample(input, fromRate, toRate) {\n    if (fromRate === toRate) return input;\n    \n    const ratio = fromRate / toRate;\n    const newLength = Math.round(input.length / ratio);\n    const result = new Float32Array(newLength);\n    \n    for (let i = 0; i < newLength; i++) {\n      const originalIndex = i * ratio;\n      const index1 = Math.floor(originalIndex);\n      const index2 = Math.min(index1 + 1, input.length - 1);\n      const weight = originalIndex - index1;\n      \n      result[i] = input[index1] * (1 - weight) + input[index2] * weight;\n    }\n    \n    return result;\n  }\n\n  detectVoice(data) {\n    let sumSquares = 0;\n    for (let i = 0; i < data.length; i++) {\n      sumSquares += data[i] * data[i];\n    }\n    const rms = Math.sqrt(sumSquares / data.length);\n    return rms > this.vadThreshold;\n  }\n\n  floatTo16BitPCM(input) {\n    const output = new Int16Array(input.length);\n    for (let i = 0; i < input.length; i++) {\n      // Soft-clip limiter\n      const s = Math.tanh(input[i]);\n      output[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;\n    }\n    return output;\n  }\n\n  calculateHangover(speakingFrames) {\n    // Assuming ~128 samples per chunk at 16kHz = 8ms\n    // 2 seconds = 250 chunks\n    if (speakingFrames > 250) {\n      return 187; // ~1.5s\n    }\n    return 62; // ~500ms\n  }\n}\n\nregisterProcessor('audio-processor', AudioProcessor);\n`;\n","\nimport { WORKLET_CODE } from '../worklet/AudioProcessorString';\n\nexport interface AudioRecorderOptions {\n    sampleRate?: number;\n    onDataAvailable?: (data: Int16Array) => void;\n    onVADChange?: (isSpeaking: boolean) => void;\n    onBargeIn?: () => void;\n}\n\nexport class AudioRecorder {\n    private context: AudioContext | null = null;\n    private workletNode: AudioWorkletNode | null = null;\n    private stream: MediaStream | null = null;\n    private options: AudioRecorderOptions;\n    private isRecording = false;\n    private analyser: AnalyserNode | null = null;\n\n    constructor(options: AudioRecorderOptions) {\n        this.options = options;\n    }\n\n    async start() {\n        if (this.isRecording) return;\n\n        try {\n            this.stream = await navigator.mediaDevices.getUserMedia({\n                audio: {\n                    echoCancellation: true,\n                    noiseSuppression: true,\n                    autoGainControl: true\n                }\n            });\n\n            // Create AudioContext with desired sample rate if supported, otherwise default\n            // Note: We resample in the worklet, so we can let the context run at native rate (usually 44.1 or 48k)\n            // to avoid hardware resampling issues.\n            this.context = new AudioContext();\n\n            await this.context.resume();\n\n            // Load the worklet\n            // TODO: This needs to be replaced with the actual Blob URL or file path in the final build\n            // For now, we assume a specific path or we will inject it.\n            // We'll use a helper method to get the worklet URL.\n            const workletUrl = this.getWorkletUrl();\n            await this.context.audioWorklet.addModule(workletUrl);\n\n            const source = this.context.createMediaStreamSource(this.stream);\n            this.workletNode = new AudioWorkletNode(this.context, 'audio-processor');\n\n            // Visualizer Support\n            this.analyser = this.context.createAnalyser();\n            this.analyser.fftSize = 256;\n            source.connect(this.analyser);\n\n            this.workletNode.port.onmessage = (event) => {\n                const { type, data } = event.data;\n\n                if (type === 'AUDIO_DATA') {\n                    if (this.options.onDataAvailable) {\n                        this.options.onDataAvailable(new Int16Array(data));\n                    }\n                } else if (type === 'VAD_START') {\n                    if (this.options.onVADChange) {\n                        this.options.onVADChange(true);\n                    }\n                    if (this.options.onBargeIn) {\n                        this.options.onBargeIn();\n                    }\n                } else if (type === 'VAD_END') {\n                    if (this.options.onVADChange) {\n                        this.options.onVADChange(false);\n                    }\n                }\n            };\n\n            source.connect(this.workletNode);\n            // We don't connect to destination to avoid feedback loop (hearing yourself)\n\n            this.isRecording = true;\n        } catch (error) {\n            console.error('Failed to start recording:', error);\n            throw error;\n        }\n    }\n\n    stop() {\n        if (!this.isRecording) return;\n\n        if (this.stream) {\n            this.stream.getTracks().forEach(track => track.stop());\n            this.stream = null;\n        }\n\n        if (this.workletNode) {\n            this.workletNode.disconnect();\n            this.workletNode = null;\n        }\n\n        if (this.context) {\n            this.context.close();\n            this.context = null;\n        }\n\n        this.isRecording = false;\n    }\n\n    // This is the magic part where we will inject the worker code\n    private getWorkletUrl(): string {\n        const blob = new Blob([WORKLET_CODE], { type: 'application/javascript' });\n        return URL.createObjectURL(blob);\n    }\n\n    getFrequencies(): Float32Array {\n        if (!this.analyser) return new Float32Array(0);\n        const data = new Float32Array(this.analyser.frequencyBinCount);\n        this.analyser.getFloatFrequencyData(data);\n        return data;\n    }\n}\n","\nimport { useState, useRef, useCallback, useEffect } from 'react';\nimport { AudioRecorder } from '../core/AudioRecorder';\n\nexport interface UseAudioRecorderOptions {\n    sampleRate?: number;\n}\n\nexport const useAudioRecorder = (options: UseAudioRecorderOptions = {}) => {\n    const [isRecording, setIsRecording] = useState(false);\n    const [isSpeaking, setIsSpeaking] = useState(false);\n    const recorderRef = useRef<AudioRecorder | null>(null);\n\n    // We expose a method to set the socket or callback for data\n    const start = useCallback(async (onData?: (data: Int16Array) => void) => {\n        if (recorderRef.current) return;\n\n        const recorder = new AudioRecorder({\n            sampleRate: options.sampleRate,\n            onDataAvailable: (data) => {\n                if (onData) onData(data);\n            },\n            onVADChange: (speaking) => {\n                setIsSpeaking(speaking);\n            }\n        });\n\n        try {\n            await recorder.start();\n            recorderRef.current = recorder;\n            setIsRecording(true);\n        } catch (err) {\n            console.error(\"Error starting recorder:\", err);\n        }\n    }, [options.sampleRate]);\n\n    const stop = useCallback(() => {\n        if (recorderRef.current) {\n            recorderRef.current.stop();\n            recorderRef.current = null;\n            setIsRecording(false);\n            setIsSpeaking(false);\n        }\n    }, []);\n\n    useEffect(() => {\n        return () => {\n            if (recorderRef.current) {\n                recorderRef.current.stop();\n            }\n        };\n    }, []);\n\n    return {\n        start,\n        stop,\n        isRecording,\n        isSpeaking\n    };\n};\n","export class AudioPlayer {\n    private context: AudioContext;\n    private sampleRate: number;\n    private nextStartTime: number = 0;\n    private scheduledSources: AudioBufferSourceNode[] = [];\n    private readonly BUFFER_MS = 40; // 40ms initial buffer\n\n    constructor(context: AudioContext, sampleRate: number = 24000) {\n        this.context = context;\n        this.sampleRate = sampleRate;\n    }\n\n    addAudio(data: Int16Array) {\n        const float32 = new Float32Array(data.length);\n        for (let i = 0; i < data.length; i++) {\n            float32[i] = data[i] / 32768; // 0x8000\n        }\n\n        const buffer = this.context.createBuffer(1, float32.length, this.sampleRate);\n        buffer.copyToChannel(float32, 0);\n\n        const currentTime = this.context.currentTime;\n\n        // Jitter Buffer Logic:\n        // If we are starving (nextStartTime < currentTime), add safety buffer\n        if (this.nextStartTime < currentTime) {\n            this.nextStartTime = currentTime + (this.BUFFER_MS / 1000);\n        }\n\n        // Elastic Logic:\n        // Calculate latency\n        const latency = this.nextStartTime - currentTime;\n        let playbackRate = 1.0;\n        if (latency > 0.2) { // If > 200ms latency, speed up\n            playbackRate = 1.05;\n        }\n\n        const source = this.context.createBufferSource();\n        source.buffer = buffer;\n        source.playbackRate.value = playbackRate;\n        source.connect(this.context.destination);\n        source.start(this.nextStartTime);\n\n        this.scheduledSources.push(source);\n\n        // Cleanup finished sources\n        source.onended = () => {\n            const index = this.scheduledSources.indexOf(source);\n            if (index > -1) {\n                this.scheduledSources.splice(index, 1);\n            }\n        };\n\n        this.nextStartTime += buffer.duration / playbackRate;\n    }\n\n    clear() {\n        this.scheduledSources.forEach(source => {\n            try {\n                source.stop();\n            } catch (e) {\n                // ignore\n            }\n        });\n        this.scheduledSources = [];\n        this.nextStartTime = 0;\n    }\n}\n","export const unlockAudioContext = async (context: AudioContext) => {\n    if (context.state === 'running') return;\n\n    const unlock = () => {\n        // Create a short silent buffer\n        const buffer = context.createBuffer(1, 1, 22050);\n        const source = context.createBufferSource();\n        source.buffer = buffer;\n        source.connect(context.destination);\n        source.start(0);\n\n        if (context.state !== 'running') {\n            context.resume();\n        }\n\n        // Remove listeners once triggered\n        document.removeEventListener('click', unlock);\n        document.removeEventListener('touchstart', unlock);\n        document.removeEventListener('keydown', unlock);\n    };\n\n    // Listen for any interaction\n    document.addEventListener('click', unlock);\n    document.addEventListener('touchstart', unlock);\n    document.addEventListener('keydown', unlock);\n};\n","import { useState, useEffect, useRef, useCallback } from 'react';\nimport { AudioRecorder } from '../core/AudioRecorder';\nimport { AudioPlayer } from '../core/AudioPlayer';\nimport { TransportAdapter } from '../core/TransportAdapter';\nimport { unlockAudioContext } from '../core/BrowserUtils';\n\nexport type LiveAudioState = 'idle' | 'listening' | 'thinking' | 'speaking';\n\nexport interface UseLiveAudioOptions {\n    transport: TransportAdapter;\n    sampleRate?: number;\n}\n\nexport const useLiveAudio = ({ transport, sampleRate = 24000 }: UseLiveAudioOptions) => {\n    const [state, setState] = useState<LiveAudioState>('idle');\n    const [frequencyData, setFrequencyData] = useState<Float32Array>(new Float32Array(0));\n    const recorderRef = useRef<AudioRecorder | null>(null);\n    const playerRef = useRef<AudioPlayer | null>(null);\n    const audioContextRef = useRef<AudioContext | null>(null);\n    const animationFrameRef = useRef<number | null>(null);\n\n    const start = useCallback(async () => {\n        try {\n            // 1. Setup AudioContext\n            // We use the browser's native sample rate for the context to avoid issues, \n            // but we tell the recorder/player what our target rate is.\n            const context = new AudioContext();\n            audioContextRef.current = context;\n            await unlockAudioContext(context);\n\n            // 2. Setup Player\n            const player = new AudioPlayer(context, sampleRate);\n            playerRef.current = player;\n\n            // 3. Setup Recorder\n            const recorder = new AudioRecorder({\n                sampleRate,\n                onDataAvailable: (data) => {\n                    transport.send(data);\n                },\n                onVADChange: (isSpeaking) => {\n                    if (isSpeaking) {\n                        setState('listening');\n                        // Barge-In: Clear player\n                        player.clear();\n                        // Send cancel\n                        transport.send({ type: 'cancel_response' });\n                    } else {\n                        setState('thinking');\n                    }\n                },\n                onBargeIn: () => {\n                    // Redundant if onVADChange handles it, but safe\n                }\n            });\n            recorderRef.current = recorder;\n\n            // 4. Connect Transport\n            await transport.connect((data) => {\n                // Received audio from AI\n                if (data instanceof ArrayBuffer || data instanceof Int16Array) {\n                    setState('speaking');\n                    // Ensure data is Int16Array\n                    const audioData = data instanceof Int16Array ? data : new Int16Array(data);\n                    player.addAudio(audioData);\n                }\n            });\n\n            await recorder.start();\n            setState('listening'); // Initial state\n\n            // Visualizer Loop\n            const updateVisualizer = () => {\n                if (recorderRef.current) {\n                    const data = recorderRef.current.getFrequencies();\n                    setFrequencyData(data);\n                }\n                animationFrameRef.current = requestAnimationFrame(updateVisualizer);\n            };\n            updateVisualizer();\n        } catch (error) {\n            console.error(\"Failed to start live audio:\", error);\n            setState('idle');\n        }\n\n    }, [transport, sampleRate]);\n\n    const stop = useCallback(() => {\n        if (animationFrameRef.current) {\n            cancelAnimationFrame(animationFrameRef.current);\n        }\n        recorderRef.current?.stop();\n        playerRef.current?.clear();\n        transport.disconnect();\n        setState('idle');\n    }, [transport]);\n\n    useEffect(() => {\n        return () => {\n            stop();\n        };\n    }, [stop]);\n\n    return {\n        start,\n        stop,\n        state,\n        frequencyData\n    };\n};\n","export interface TransportAdapter {\n    connect(onMessage: (data: any) => void): Promise<void>;\n    send(data: any): void;\n    disconnect(): void;\n    onStateChange?: (state: 'connected' | 'connecting' | 'disconnected') => void;\n}\n\nexport abstract class BaseTransportAdapter implements TransportAdapter {\n    protected state: 'connected' | 'connecting' | 'disconnected' = 'disconnected';\n    public onStateChange?: (state: 'connected' | 'connecting' | 'disconnected') => void;\n\n    abstract connect(onMessage: (data: any) => void): Promise<void>;\n    abstract send(data: any): void;\n    abstract disconnect(): void;\n\n    protected setState(newState: 'connected' | 'connecting' | 'disconnected') {\n        this.state = newState;\n        if (this.onStateChange) {\n            this.onStateChange(newState);\n        }\n    }\n\n    // Exponential Backoff Reconnection Logic\n    protected async withBackoff(fn: () => Promise<void>) {\n        let attempt = 0;\n        while (true) {\n            try {\n                this.setState('connecting');\n                await fn();\n                this.setState('connected');\n                return;\n            } catch (e) {\n                attempt++;\n                this.setState('disconnected'); // Or 'reconnecting'\n\n                // Wait 200ms, 500ms, 1s...\n                const delay = attempt === 1 ? 200 : Math.min(500 * Math.pow(2, attempt - 2), 10000);\n\n                console.warn(`Connection failed, retrying in ${delay}ms...`, e);\n                await new Promise(r => setTimeout(r, delay));\n            }\n        }\n    }\n}\n","import * as ort from 'onnxruntime-web';\n\nexport interface VADAdapter {\n    process(audioFrame: Float32Array): Promise<boolean>;\n    reset(): void;\n}\n\nexport class SileroVADAdapter implements VADAdapter {\n    private loaded = false;\n    private session: ort.InferenceSession | null = null;\n    private h: ort.Tensor | null = null;\n    private c: ort.Tensor | null = null;\n    private readonly sr: ort.Tensor;\n\n    constructor(private modelUrl: string) {\n        this.sr = new ort.Tensor('int64', new BigInt64Array([16000n]));\n    }\n\n    async load() {\n        if (this.loaded) return;\n        try {\n            this.session = await ort.InferenceSession.create(this.modelUrl);\n            this.reset();\n            this.loaded = true;\n        } catch (e) {\n            console.error(\"Failed to load VAD model\", e);\n        }\n    }\n\n    async process(audioFrame: Float32Array): Promise<boolean> {\n        if (!this.loaded || !this.session || !this.h || !this.c) {\n            // Fallback to energy check if model not loaded\n            let sum = 0;\n            for (let i = 0; i < audioFrame.length; i++) {\n                sum += audioFrame[i] * audioFrame[i];\n            }\n            return Math.sqrt(sum / audioFrame.length) > 0.02;\n        }\n\n        const input = new ort.Tensor('float32', audioFrame, [1, audioFrame.length]);\n\n        const feeds: Record<string, ort.Tensor> = {\n            input: input,\n            sr: this.sr,\n            h: this.h,\n            c: this.c\n        };\n\n        const results = await this.session.run(feeds);\n\n        // Update states\n        this.h = results.hn;\n        this.c = results.cn;\n\n        const output = results.output;\n        const probability = output.data[0] as number;\n\n        return probability > 0.5;\n    }\n\n    reset() {\n        // Reset internal state (RNN states) for Silero (2, 1, 64)\n        const zeros = new Float32Array(2 * 1 * 64).fill(0);\n        this.h = new ort.Tensor('float32', zeros, [2, 1, 64]);\n        this.c = new ort.Tensor('float32', zeros, [2, 1, 64]);\n    }\n}\n"]}